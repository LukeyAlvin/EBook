## 划分数组问题

划分一：以数组中最后一位 $x$ 为划分值，要求：$\le x$ 放数组左边，$>x$ 放数组右边 ，并返回划分值所在的下标；

> 输入：[3, 4, 6, 0, 7, 4, 5, 1, 3]
>
> 以3为划分值：[3,  0,  1,  **3** , 7,  4,  5,  6,  4 ]
>
> 输出：3
>
> 输入：[2, 1, 5, 5, 2, 6, 7, 4] 
>
> 以4为划分值：[2, 1, 2, **4**, 5, 6, 7, 5 ]
>
> 输出：3

解决思路：

- 当前数 $\le x$ ，则当前数与 $\le$ 区下一个数交换，$\le$ 区向右扩，当前数跳下一个；
- 当前数 $>x$ ，则当前数跳下一个； 

```c++
void swap(vector<int> &nums, int i, int j)
{
    int temp;
    temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
int partition1(vector<int> &nums, int L, int R)
{
    // basecase
    if (L > R)
        return -1;
    if (L == R)
        return L;

    int index = L;         // 当前数
    int lessEqual = L - 1; // 小于等于区
    while (index < R) // 到达 size-1位置停止
    {
        if (nums[index] <= nums[R])
            swap(nums, index, ++lessEqual);
        index++;
    }
    // 最后把最后一位放到小于等于区域下一个
    swap(nums, ++lessEqual, R);
    return lessEqual;
} 
```

## 荷兰国旗问题

划分二：以数组中最后一位 $x$ 为划分值，$<x$ 放数组左边，$=x$放中间， $>x$ 放数组右边 

解决思路：

- 当前数$<x$ ，则当前数与 $<$ 区下一个数交换， $<$ 区向右扩，当前数跳下一个；
- 当前数$=x$ ，则当前数跳下一个； 
- 当前数 $>x$ ，则当前数与 $>$ 区前一个数交换， $>$ 区向左扩，当前数不动，观察交换后的数与 $x$ 的大小

> 输入：[3, 4, 6, 0, 7, 4, 5, 1, 3, 4]
>
> 以4为划分值：[3,  3,  0,  1 , **4,  4,  4**, 7,  6,  5 ]
>
> 输出：[4 , 6]

```cpp
void swap(vector<int> &nums, int i, int j)
{
    int temp;
    temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

vector<int> partition2(vector<int> &nums, int L, int R)
{   
    if(L == R) return {L, R};
    if(L > R) return {-1, -1};
    int le = L - 1;
    int ge = R;         // 先不让最后一位数别动，作为参考
    int index = L;
    while (index < ge)	// 当前数撞上大于区域
    {
        if(nums[index] < nums[R])
        {
            swap(nums, index++, ++le);
        }else if(nums[index] == nums[R])
        {
            index++;
        }else{
            swap(nums, index, --ge);
        }
    }
    swap(nums, ge, R);      // 最后一个数放在大于区域第一个数
    return {le + 1, ge};     // 返回等于区域的范围
}
```

## 快速排序

**快排1.0：**按照划分数组问题，先把数组划分成 $[\le x, >x]$，然后将 $\le$ 区域最后一个数固定不动，将左半部分和右半部分分别看成数组，继续进行数组划分，各自确定一个数不动，以此递归下去；算法复杂度：$O(N^2)$

**快排2.0：**按照荷兰国旗问题，先把数组划分成 $[< x, =x, >x]$，返回等于区域下标范围，等于区域不动，将左半部分小于区域和右半部分大于区域分别看成数组，继续进行数组划分，各自确定等于区域下标范围，以此递归下去；算法复杂度：$O(N^2)$

```cpp
void quickSort(vector<int> & nums)
{
    // basecase
    if(nums.empty() || nums.size() < 2)
        return;
    process(nums, 0, nums.size() - 1);
}
void process(vector<int> & nums, int L, int R)
{
    // breakcase
    if(L >= R) return; // 当只有一个数的时候，终止递归
    vector<int> equalArea = partition2(nums, L, R); // 调用荷兰国旗
    process(nums, L, equalArea[0] - 1);
    process(nums, equalArea[1] + 1, R);
}
```

**快排3.0：**原始的划分方式，是固定原则最右侧的位置的数作为划分值，可以随机选择一个数，与最右侧的值交换，然后再以最右侧的值作为划分值，这样算法的空间复杂度为：$\log(N)$，时间复杂度变为：$N*\log(N)$.

```cpp
void quickSort(vector<int> & nums)
{
    // basecase
    if(nums.empty() || nums.size() < 2)
        return;
    process(nums, 0, nums.size() - 1);
}
void process(vector<int> & nums, int L, int R)
{
    // breakcase
    if(L >= R) return; // 当只有一个数的时候，终止递归
    srand(time(NULL)); // 设置随机数种子为当前时间
    swap(nums, L + rand() % (R - L + 1), R);
 	vector<int> equalArea = partition2(nums, L, R); // 调用荷兰国旗
    process(nums, L, equalArea[0] - 1);
    process(nums, equalArea[1] + 1, R);
}
```

可以看出仅仅是增加了下面两行代码：

```cpp
srand(time(NULL)); // 设置随机数种子为当前时间
swap(nums, L + rand() % (R - L + 1), R);
```

## 快速选择

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

> **示例 1:**
>
> ```
> 输入: [3,2,1,5,6,4], k = 2
> 输出: 5
> ```
>
> **示例 2:**
>
> ```
> 输入: [3,2,3,1,2,4,5,5,6], k = 4
> 输出: 4
> ```

这个题目利用了快排中的荷兰国旗问题：

例如：[3,2,1,5,6,4]，找第 `k=2` 大的数，显然第二大的数应该在有序数组中排 `nums.size()-k`，即第`target = 4`的位置，将数组进行partition后：[3 2 1 **4** 5 6 ] ，可以发现 `4` 所在位置为 `mid = 3 < target`，因此，目标数一定在 4 的右边，则对 [mid+1,  R] 上再次进行partition，直至 `L==R`，即还剩一个数的时候。

```c++
int findKthLargest(vector<int> &nums, int k)
{
    int L = 0;
    int R = nums.size() - 1;
    int target = nums.size() - k; // 第K大的数，应该排在 nums.size() - K 的位置
    while (L < R)
    {
        srand(time(NULL)); // 设置随机数种子为当前时间
        swap(nums, L + rand() % (R - L + 1), R);
        // 调用快排的partition
        int mid = partition(nums, L, R); 
        if (mid == target)
            return nums[mid];
        if (mid < target) // 枢轴元素在第 K 大元素的左边，继续处理右半部分
            L = mid + 1;
        else 			  // 枢轴元素在第 K 大元素的右边，继续处理左半部分
            R = mid - 1;
    }
    return nums[L]; // 当 L == R 时，找到了第 K 大的元素，返回 nums[L]
}
```

