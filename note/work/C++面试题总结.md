# C++基础

### 【1】：C++中的`this`指针的作用是什么？在什么时候使用？

> 关键词：`this`指针

在 C++ 中，`this` 指针是一个指向当前对象的指针，它可以被用来访问当前对象的成员变量和成员函数。
① 当成员变量和参数变量名字相同时，`this` 指针可以被用来区分它们。
② 在类的非静态成员函数中，`this` 指针还可以用来返回当前对象的引用。

```c++
class MyClass {
private:
  int x;
public:
  MyClass& increment() {
    this->x++; 		// 等价于 x++;
    return *this;	// 返回当前对象
  }
};
```

> 注：静态成员函数没有 `this` 指针，因为它们与任何特定的对象无关。

### 【2】：C++的 new 和 delete，什么时候用 new 申请，用 delete 释放？

当你需要动态分配内存时，使用 `new` 关键字，使用 `new` 时，当确定不再需要分配的内存时，应该始终使用对应的 `delete` 运算符来释放内存。因为 `new` 动态分配的内存在程序结束后不会自动释放，如果你不释放它，会导致内存泄漏。

如果你使用 `new` 分配了内存，但在某些情况下无法使用 `delete` 来释放它，例如当程序异常结束时，可能会导致内存泄漏。为了避免这种情况，在 `C++11` 及之后的版本中，建议使用智能指针来管理动态分配的内存，例如 `std::shared_ptr` 或 `std::unique_ptr`，它们可以在对象超出作用域时自动释放内存。

`delete` 释放内存时，会做以下几个步骤：

- 调用被释放对象的析构函数
- 操作系统并不会立即将该内存归还给系统，将该内存块标记为可用状态，等待后续的内存分配操作再次使用该块内存。这种方式可以提高程序的效率，避免了频繁的向操作系统申请内存的开销。

### 【3】：C++的 `static` 关键字的作用（我从 `elf`结构，链接过程来回答）？

`static` 关键字可以用来声明静态变量、静态函数和静态类成员。它们在程序的整个生命周期内保持不变，并且在链接过程中被分配和初始化。在 `ELF` 结构中，它们都可以存储在可执行文件的数据段和代码段中，而不是堆栈中，可以在链接时被其他文件引用。

### 【4】：C++如何调用C语言语句？

在 C++ 中使用 `extern "C"` 声明来告诉编译器需要调用` C` 语言的相关头文件，然后就可以像调用 C 语言代码一样在 `C++` 中使用这些函数和变量。例如： 

```c++
extern "C" {
    #include "my_c_header.h"
}
```

### 【5】：C++如何防止内存泄露？智能指针详述？

`C++` 中内存泄露是指在程序运行过程中分配的内存没有及时释放，导致程序消耗的内存越来越多，最终可能导致程序崩溃。

智能指针是 `C++` 中一种用于自动管理内存的指针类，它能够在不需要指针时自动释放动态分配的内存，从而避免内存泄漏的问题。它主要是通过封装一个裸指针（`raw pointer`）并在其上增加一些附加功能，如自动释放内存等，实现了对内存的自动管理。

常用的智能指针包括 `unique_ptr、shared_ptr` 和 `weak_ptr`。

- `unique_ptr` 是独占式智能指针，它只能指向唯一的对象，并负责自动释放该对象的内存。
- `shared_ptr` 是共享式智能指针，可以在多个指针之间共享同一个对象，并自动管理内存的释放。使用 `shared_ptr` 时需要注意循环引用的问题，因为如果两个 `shared_ptr` 指向彼此，则会导致内存泄漏。 
- `weak_ptr` 是一种辅助 `shared_ptr` 使用的指针，可以协助解决 `shared_ptr` 可能导致的循环引用问题。

问题：C++的继承？
问题：C+的继承多态，空间配置器，vector和Iist的区别，map,多重map?

问题：

# STL相关



