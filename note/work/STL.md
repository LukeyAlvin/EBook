# STL六大部件

1. **容器（containers）**

   就是存放数据的各种数据结构，常用的包括vector、list、deque、set、map、multiset、multimap等

2. **算法（algorithms）**

   常用算法，常用的有sort、search、copy、erase等

3. **迭代器（iterators）**

   是容器与算法之间的桥梁，是一种泛型的指针，重载了指针的方法，如 `operate*,operate->,operate++，operate--` 等，每个容器都有专属于自己的迭代器。原生指针其实也是一种迭代器。

4. **仿函数（functors）**

   行为类似函数，就是使一个类的使用看上去象一个函数，具有可配接性。它的具体实现就是通过在类中重载了operator()，使这个类具有了类似函数的行为，就是一个仿函数类了。一般函数指针、回调函数可视为狭义的仿函数。以操作数的个数划分，可分为一元和二元仿函数；以功能划分，可分为算术运算、关系运算、逻辑运算三大类。这部分内建的仿函数，均放在头文件里，使用时需引入头文件

5. **适配器（adapters）**

   用来修饰容器、仿函数或迭代器接口的东西，如 `queue、stack` ，内部其实都是借助 `deque` 来实现的。改变functor接口者，称为functor adapter，改变container接口者，称为container adapter；改变iterator接口者，称为iterator adapter。

6. **分配器（allocators）**

   负责内存配置和管理。是一个实现了动态空间配置、空间管理、空间释放的class template。一般SGI STL为每一个容器都指定其缺省的空间配置器为alloc（SGI配置器）

<img src="/home/alivn/Documents/note/work/images/Blog/STL/image-20230311200504091.png" alt="image-20230311200504091" style="zoom: 33%;" />

1. `allocator<int>` 是**容器**`vector`的**分配器**  一般可以不写；
2. `count_if(InputIt first, InputIt last, UnaryPredicate p)`

`count_if`是C++ STL中的一个**算法函数**，用于计算满足特定条件的元素的数量。`first` 和 `last`参数表示要计数的元素的范围，`vi.begin(), vi.end()` 是**迭代器**，`p` 是一个一元谓词，表示计数条件。该函数返回满足条件的元素的数量。

3. `bind2nd(less<int>(), 40))`

`bind2nd`是C++ STL中的一个**函数适配器**，用于将一个二元函数转换为一个一元函数。`less<int>()`表示一个**函数对象**（或**仿函数**），它的作用是比较两个int类型的值，如果第一个值小于第二个值，则返回`true`，否则返回`false`。`40`是要绑定的第二个参数的值，也就是说，使用`bind2nd`函数将`less<int>()`函数对象转换为一个只接受一个int参数的函数对象，并且绑定了第二个参数的值为40。

4. `not1`

`not1`是C++ STL中的一个**函数适配器**，用于将一个一元谓词转换为另一个一元谓词，返回的谓词与原谓词相反。代码中则是将" $<40$ 的数" 的条件，通过 `not1` 转换为 " $\ge40$ 的数" 

# 容器的结构性分类

## 序列式容器

序列式容器的元素是可序的，但未必都是有序的。主要分为以下几种：

- Array：大小固定的数组容器。
- Vector：大小可变的数组容器，只能从尾端添加元素。
- Deque：大小可变的数组容器，可以从头部和尾部添加元素。
- List：双向链表容器。
- Forward List：单向链表容器。

容器适配器也属于序列式容器，包括：

- Stack：基于deque实现的堆栈容器。
- Queue：基于deque实现的队列容器。
- Priority Queue：基于vector实现的优先级队列容器。

## 关联式容器

关联式容器的每个元素都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器内部数据结构（如红黑树或哈希表）根据键值大小以某种特定规则将该元素放置于适当位置。

关联式容器没有头尾（只有最大元素和最小元素），所以不会有push_back()、push_front()、pop_back()、pop_front()、begin()、end()等操作。

**Set：**集合容器，每个元素都唯一，默认按照元素的大小进行排序，因此元素必须实现比较运算符，set只有键值(key)，没有值(value).

**Map：**映射表容器，其中元素由一个键值(key)和对应的值(value)组成，键值(key)唯一，并且按照键值进行排序。map中的元素必须实现比较运算符。

multiset 和 multimap是set和map的衍生容器，允许存储具有相同键值的元素。multiset和multimap中的元素按键值排序，而不是按值排序。

**Multiset：**多键集合容器，键值可以重复，允许存储具有相同键值的元素，按键值自动排序。Multiset只有键值(key)，没有值(value).

**Multimap：**多键映射表容器，每个元素都有一个键值和一个实值，键值可以重复，按键值自动排序。

# OOP & GP

在面向对象编程（Object-oriented programming）中，企图将数据（data）和方法（method）关联在一起，即抽象的单位是**对象**，而对象是由数据和方法组成的。类是对象的模板，对象是类的实例化。通过继承、多态等机制实现代码的复用和灵活性。面向对象编程适合实现相对较为复杂的系统，对于数据封装、模块化、可维护性、代码复用等方面都有很好的支持。

而在泛型编程（Generic Programming ）中，抽象的单位是**算法和数据类型**。通过使用模板和泛型算法实现对不同数据类型的代码复用，将数据类型和算法解耦，提高了代码的灵活性和可重用性。

![image-20230311202142318](/home/alivn/Documents/note/work/images/Blog/STL/image-20230311202142318.png)

如图所示，`vector`与`deque` 均提供 `RandomAccessIterator`，数据位于容器中，与算法分离，算法则通过迭代器确定操作范围，取用容器中数据元素。

另外就是，所有的算法，其内部最终<u>涉及元素本身</u>的操作无非是<u>比大小</u>。

<img src="/home/alivn/Documents/note/work/images/Blog/STL/image-20230217202117150.png" alt="image-20230217202117150" style="zoom: 50%;" />

# 分配器

分配器`allocator`

在大多数实现中，`operator new`会调用 `malloc` 来分配内存。`malloc`是C标准库中的函数，用于动态分配内存。需要注意的是，malloc分配的内存空间大小通常会比实际需要的内存大小大。如果程序频繁分配和释放内存，可能会导致内存空间的浪费。

> `malloc` 分配内存时，需要在分配的内存块前后添加额外的一些元数据，用于记录内存块的大小、是否空闲等信息。这些额外的元数据被称为overhead。overhead的大小与分配的内存块大小有关。
>
> 当分配小内存时，overhead的比例就会更大，因为额外的元数据所占用的比例更高。例如，当我们需要分配1字节的内存时，实际上可能需要分配8字节或更多的内存，因为需要在前后添加overhead。
>
> 而当分配大内存时，overhead的比例就会变小，因为额外的元数据所占用的比例相对较低。例如，当我们需要分配1GB的内存时，实际上可能只需要多分配几KB的overhead，而这个overhead在1GB的内存中所占比例非常小。

事实上，对于VC6和BC5等比较老的编译器，它们在实现 `allocator` 时，只是以 `::operator new` 以及 `::operator delete` 完成 `allocate()` 以及 `deallocate()`，并没有任何特殊设计，但是由于`allocate()`通过调用`::operator new` ，进而调用的是 `malloc` 进行内存分配，会产生额外的 `overhead`，而即使调用`::operator delete`  进而调动 `free` 也只能释放 `malloc` 返回的指针所指向的内存块，而不会释放 `malloc` 内部用于维护管理信息的 `overhead` 。因此，如果频繁地进行小块内存分配和释放操作，就会造成大量的overhead 内存浪费，这也是使用C++ STL时选择使用内存池的一个原因。

而在G2.9（GNU编译器的一个版本）中，allocator的使用和C++98标准是一致的，可以使用标准库中提供的allocator类或自定义的allocator类进行内存的分配和释放。但是，实际上，源代码并不支持使用标准库中提供的allocator类，而更推荐或自定义的allocator类。

在容器中，由于元素类型是一样的，因此每个元素的内存大小都是固定的、一致的，因此在容器中使用 `malloc` 分配内存的方式也不是最优的选择，即记录每个元素开辟的内存大小。而GNU编译器就以此入手，尽量减少 `malloc` 次数。

在GNU编译器中，为了避免频繁地调用 `malloc` 函数，提高内存分配的效率，实现了一个**内存池管理机制**。这个内存池由多条链表组成，每条链表维护一定大小的内存块。

![1493_1678543061_hd](/home/alivn/Documents/note/work/images/Blog/STL/1493_1678543061_hd.jpeg)

当需要分配一块内存时，首先根据内存大小找到对应的链表，如果该链表中没有可用的内存块，就从下一个更大的链表中查找。如果所有链表都没有可用的内存块，就调用 `malloc` 函数申请更多的内存。分配的内存块如果不用了，就可以被放回链表中，供下一次分配使用，这样可以避免频繁调用 `malloc` 和 `free` 函数，提高了内存分配的效率。

**使用内存池管理机制的好处在于可以避免频繁调用 `malloc` 和 `free` 函数，减少了内存碎片的产生，并且可以更好地利用缓存，提高了内存分配的效率。**

> 但是在而在G4.5 之后，把这种机制又改回去了.......

# List



# 其他

前闭后开区间

迭代器中的`vi.begin()`指的是容器的第一个元素，而` vi.end()` 指的是最后一个元素的下一个位置

```c++
Container<T> c;
Container<T>::iterator ite = c.begin();
for(; ite != c.end(); ++ite)
```

如果对` c.end()`解引用，即`*(c.end())`，是不合法的。



malloc分配内存会多开出吗？为什么？多开出的是什么？

是的，malloc分配内存时会多开出一些空间，这些空间称为“边界标记”（boundary tag）。

边界标记包含两个部分：一个是上一个块的结束位置（即块的末尾），另一个是当前块的大小。

这是因为当使用free释放内存时，需要确定哪些块是相邻的，以便进行合并。因此，边界标记用于在释放内存时确定相邻块的位置和大小。

此外，还有可能会在内存块的开始位置多开出一些空间，称为“对齐空间”（alignment space），以便使得后续的内存访问更加高效。对齐空间的大小通常是内存对齐的倍数，可以通过特定的宏定义或函数调用来设置。