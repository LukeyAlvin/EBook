# OS概述

## OS的概念和目标

操作系统(Operation System)，简称OS，是管理计算机『硬件』与『软件』资源的计算机程序。

OS是一种『系统软件』，OS做了哪些事？

- 管理与配置内存
- 决定系统资源供需的优先次序
- 控制输入设备与输出设备
- 操作网络与管理文件系统等基本事务
- 提供一个让用户与系统交互的操作界面

## OS的功能和目标

目标：

- 有效性：提高系统资源利用率、管理系统资源、提高系统的吞吐量
- 方便性：方便用户使用
- 可扩充性：作为扩充机器
- 开放性

功能：

- 作为计算机系统资源的管理者：处理机管理、存储器管理、文件管理、设备管理
- 作为用户与计算机『硬件系统』之间的接口：程序接口、命令接口、GUl (Graphical User Interface)图形用户接口
- 实现了对计算机资源的抽象：将具体的计算机硬件资源抽象成软件资源方便用户使用、开放了简单的访问方式，隐藏了实现细节。

## OS的特征

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230308211404115-16786066977453.png" alt="image-20230308211404115" style="zoom:63%;" />

**并发性(Concurrence)：**同一时间间隔内执行和调度多个程序的能力。宏观上，处理机同时执行多道程序微观上，处理机在多道程序间高速切换（分时交替执行），关注单个处理机同一时间段内处理任务数量的能力。

> 相似概念：并行
> 并发：**同一时间间隔**（时间段）发生的事件数量
> 并行：**同一时刻**（时间点）发生的事件数量

**OS的共享性(Sharing)：**即资源共享，系统中的资源供多个『并发执行』的应用程序共同使用

- 同时访问方式：同一时段允许多个程序同时访问共享资源
- 互斥共享方式：也叫独占式，允许多个程序在同一个共享资源上独立而互不干扰的工作

并发和共享互为存在条件：

- 共享性要求OS中同时运行着多道程序，若只有单道程序正在运行，则不存在共享的可能
- 并发性难以避免的导致多道程序同时访问同一个资源，若多道程序无法共享部分资源（比如磁盘），则无法并发

**OS的虚拟技术(Virtual)：**使用某种技术把一个物理实体变成多个逻辑上的对应物，

- 时分复用技术(TDM,Time Division Multiplexing)
  - 虚拟处理机技术：“四核八线程”
  - 虚拟设备技术：虚拟打印机
- 空分复用技术(SDM,Space Division Multiplexing)
  - 虚拟磁盘技术：将一块硬盘虚拟出若干个卷
  - 虚拟存储器技术

**OS的异步性(Asynchronism)：**多道程序环境下，允许多个程序并发执行；单处理机环境下，多个程序分时交替执行；

- 程序执行的不可预知性：获得运行的时机、因何暂停、每道程序需要多少时间、不同程序的性能，比如计算多少，I/O多少
- 宏观上”一气呵成”，微观上“走走停停”



## OS的发展与分类

![image-20230308212932776](/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230308212932776-16786066977451.png)



## OS的运行机制

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230308213610173-16786066977452.png" alt="image-20230308213610173" style="zoom: 43%;" />

|                |  用户空间  | 内核空间 |
| :------------: | :--------: | :------: |
| **处理器状态** |   用户态   |  核心态  |
|    **指令**    | 非特权指令 | 特权指令 |
|    **程序**    |  应用程序  | 内核程序 |

用**程序状态字寄存器(PSW)**中的某志位来标识当前处理器处于什么状态。如0为用户态，1为核心态

**用户态（目态）：**此时CPU只能执行非特权指令；

**核心态（管态）：**特权指令、非特权指令都可执行；

**非特权指令：**比如，加、减、乘、除这些普通的运算指令。

**特权指令：**不允许用户程序使用。如内存清零指令。如果用户程序可以使用这个指令，就意味着一个用户可以将其他用户的内存数据随意清零，这样做显然是很危险的。

**内核程序：**操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在**核心态**。

**应用程序：**为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在**用户态**。

---

OS的运行机制

**时钟管理：**实现计时功能

**中断处理：**负责实现中断机制，提高多道程序环境下CPU利用率

- 外中断：中断信号来源于->外部设备

- 内中断：中断信号来源于->当前指令

  内中断的三种情况

  - 陷阱/陷入(Trap)：由应用程序主动引发
  - 故障(faut)：由错误条件引发
  - 终止(abort)：由致命错误引发

**中断的处理过程：**

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230308215105920-16786066977454.png" alt="image-20230308215105920" style="zoom:50%;" />

**原语：**是一种特殊的程序，处于操作系统最底层，是最接近硬件的部分；这种程序的运行具有原子性——<u>其运行只能一气呵成，不可中断</u>；运行时间较短、调用频繁。

**系统数据结构：**

- 进程管理：作业控制块、进程控制块
- 存储器管理：存储器分配与回收
- 设备管理：缓冲区、设备控制块

**系统调用：**由操作系统实现，给应用程序调用，系统调用的处理运行在核心态，是一套接口的集合，**应用程序访问内核服务的方式**。CPU 从用户态切换到核心态的唯一方式。

## OS的体系结构

| 操作系统结构 | 描述| 优点  | 缺点  |
| :------------------: | :----------------------------------------------------------: | :------------------------------------------------------: | :----------------------------------------------------------: |
| 第一代：无结构OS     |         一系列过程（程序）的集合，过程间可以相互调用         |                            无                            |             结构复杂且混乱，难以调试、阅读和维护             |
| 第二代：模块化结构OS | 按照功能划分模块/子模块，规定模块间的接口，独立性标准为高内聚、低耦合 | 提高正确性、可理解性和可维护性，加速开发过程，增强适应性 | 模块接口难以扩展后续需求，设计没有统一决策标准，导致接口不可靠 |
| 第三代：分层式结构OS |   采用有序分层法，自顶向下依次依赖，从底层开始自下而上建立   |            易于保证系统正确性，易于扩充和维护            |              自上而下的层次通信导致系统效率降低              |
| 第四代：微内核OS结构 | 采用微内核的架构，将操作系统的核心功能实现在一个足够小的内核中，而将与硬件处理相关的部分放在客户和服务器之间进行通信。<br />微内核OS还采用了面向对象技术，并应用了“机制与策略分离”的原则。 | 提高了操作系统的可扩展性、可靠性和可移植性，支持分布式系统，并融入了面向对象技术 | 相较于早期的操作系统，微内核OS的效率可能会降低。 |

# 进程管理

## 进程的基本概念

### 概念

进程(Process)，是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行**『资源分配和调度』**的一个独立单位。

几个要点

- 进程是**『程序』**的**『一次执行 』**`an instance of a computer program that is being executed`
- 进程是一个程序及其数据在处理机上顺序执行时所发生的**『活动』**
- 进程是程序在一个**『数据集合』**上运行的过程
- 进程是系统进行**『资源分配和调度』**的一个**『独立』**单位（或者说基本单位）

### 结构特征

#### 进程的结构

- **控制块(PCB，Process Control Block)：**进程唯一标识
- **数据段：**存放原始数据、中间数据
- **程序段：**存放在文本区域，可被多个进程共享

#### 进程的特征

- 动态性：由创建而生，由撤销而亡
- 并发性：多个进程同时运行
- 独立性：独立资源分配
- 异步性：相互独立、互不干扰

### 进程与线程

**什么是线程？**

- 线程（Thread）是进程（process）的轻型实体，也叫“轻量级进程”，是一系列活动按事先设定好的顺序依次执行的过程，是一系列指令的集合。
- 线程（Thread）是一条执行路径，不能单独存在，必须包含在进程中
- **线程是OS中运算调度的最小单位**

<img src="./images/Blog/操作系统/1196_1678450876_hd.jpg" alt="1196_1678450876_hd" style="zoom: 43%;" />

---

**为什么引入线程？**

引入线程的**主要目的是提高程序的并发性和效率**。在单线程程序中，每个任务必须在一个连续的时间段内完成，而在多线程程序中，多个任务可以同时运行，从而提高程序的并发性和效率。

线程可以在同一进程中共享内存，这意味着它们可以访问相同的数据结构，共享变量等，从而避免了在进程之间传递数据的开销。此外，线程的创建和销毁时间比进程更短，因此可以更快地响应用户请求和事件。

**线程的引入还有助于实现更复杂的程序逻辑**。例如，可以将程序分成多个任务，并将每个任务分配给不同的线程来执行。这些线程可以并发地运行，并使用同步机制来协调它们之间的操作，从而实现更高级的并发算法和数据结构。

---

**线程有哪些特点？或者说是基本属性？**

1. **轻型实体：**线程是相对于进程而言的，它是一个比进程更轻量级的实体。由于线程不需要像进程那样拥有独立的内存空间和其他系统资源，因此线程的创建和销毁时间比进程更短，开销也更小。
2. **独立调度和分派的基本单位：**线程是操作系统进行调度和分派的基本单位，每个线程都拥有自己的线程上下文，包括堆栈、程序计数器和寄存器等，这些上下文可以在不同的时间段内切换和保存，从而实现并发执行。
3. **可并发执行：**线程可以与其他线程并发执行，多个线程可以同时访问共享资源，例如内存和文件等，从而提高程序的效率和性能。同时，线程之间的并发执行也需要使用同步机制来避免竞态条件和死锁等问题。
4. **共享进程资源：**线程可以共享进程的资源，例如打开的文件、网络连接、共享内存等。这意味着线程之间可以通过共享变量等方式进行通信和协作，从而实现更高级的程序逻辑。

---

**进程和线程的区别与联系？**

| 方面                   | 进程                                                         | 线程                                                 |
| ---------------------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| **资源分配**           | 进程是操作系统分配资源的基本单位，拥有独立的资源，例如地址空间和系统资源 | 线程是进程内的轻量级实体，共享同一地址空间和系统资源 |
| **调度和切换**         | 开销较大，需要保存和恢复进程的所有状态信息                   | 开销较小，只需保存和恢复线程自己的状态信息           |
| **安全性**             | 进程之间的访问是互相隔离的，可以避免一个进程的错误破坏整个系统 | 线程之间共享资源，一个线程的错误可能会影响到整个进程 |
| **并发性**             | 进程是独立的执行单元，可以与其他进程并发执行                 | 线程是进程内的执行单元，可以与其他线程并发执行       |
| **系统开销**           | 操作系统需要为每个进程分配独立的系统资源，开销较大           | 操作系统不需要为每个线程分配独立的系统资源，开销较小 |
| **地址空间和其它资源** | 进程拥有独立的地址空间和系统资源                             | 线程共享进程的地址空间和系统资源                     |
| **通信**               | 进程之间通信需要使用进程间通信机制，例如管道、消息队列和共享内存等 | 线程之间可以通过共享变量等方式进行通信和协作         |

**重点：线程相对于进程，大大降低了创建、撤销和切换可执行实体的成本和难度。**

### 线程的实现方式

程可以通过不同的实现方式来实现并发执行，其中两种常见的实现方式是用户级线程（User-Level Thread，ULT）和内核级线程（Kernel-Level Thread，KLT）。

**用户级线程（ULT）**是由用户程序实现的线程，它不需要操作系统的支持，可以使用用户空间的线程库实现。在这种实现方式下，线程的创建、销毁和调度等操作都由用户程序自己完成，线程的切换不涉及到内核态，开销比较小，但并发性和同步机制比较受限。

**内核级线程（KLT）**是由操作系统内核实现的线程，需要操作系统提供支持。在这种实现方式下，线程的创建、销毁和调度等操作都由操作系统内核完成，线程的切换涉及到内核态，开销比较大，但并发性和同步机制比较灵活。

混合实现方式，称为多对一模型（M:N模型）。这种模型中，多个用户级线程会被映射到多个内核级线程上，从而兼具了ULT和KLT的优点，但实现起来比较复杂。

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230310210815358.png" alt="image-20230310210815358" style="zoom: 43%;" />

ULT中的多对一实现方式，是指多个用户级线程被映射到一个内核级线程上，内核对于用户级线程的调度、同步等操作是不知道的，完全由用户程序自己实现。这种方式的优点是实现简单，开销小，但是并发性和可靠性较差，当其中一个线程阻塞时，整个进程都会被阻塞，无法充分利用多核CPU。

KLT中的一对一实现方式，是指每个用户级线程都对应一个内核级线程。内核对于线程的调度、同步等操作可以直接控制，这种方式的优点是具有较好的并发性和可靠性，但开销较大，因为每个线程都需要分配内核资源。

## 进程的运行

### 进程的状态

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230311085318975.png" alt="image-20230311085318975" style="zoom:50%;" />

1. **新建状态(New)：**进程刚被创建时，处于新建状态。此时进程并未被分配到系统资源，仅仅只是在系统中被记录下来。在进程被分配到足够的资源之后，将会进入就绪状态。
2. **就绪状态(Ready)：**进程已经分配到了足够的资源，并且已经完成了初始化，等待系统调度器的调度。在就绪队列中，进程按照优先级排序，等待CPU分配资源。
3. **运行状态(Running)：**就绪队列中的进程被CPU调度器选择后，就会进入运行状态。此时进程占用CPU资源，执行程序的代码。
4. **阻塞状态(Blocked)：**如果在进程执行过程中需要等待某个事件的完成（比如等待磁盘I/O完成），那么进程就会进入阻塞状态。此时，进程的执行被暂停，系统资源被释放。一旦等待的事件完成，进程将会重新进入就绪状态。
5. **终止状态(Terminated)：**当进程执行完毕或出现错误时，进程将会进入终止状态。此时，系统资源被回收，该进程所占用的内存和其他资源被释放。终止状态也可以是由操作系统强制终止进程所导致的。

上述五种状态之间的切换，主要是由CPU调度器、进程自身以及外部事件等多种因素引起的。例如：

- 当CPU调度器在就绪队列中选择了一个新的进程时，原来正在运行的进程将会进入就绪状态；
- 当进程在执行过程中等待某个事件完成时，进程将会进入阻塞状态；
- 当进程完成了执行或者出现了错误时，进程将会进入终止状态。

### 进程控制

**进程控制：**OS对进程实现有效的管理，包括创建新进程、撤销已有进程、挂起、阻塞和唤醒、进程切换等多种操作。OS通过**原语(Primitive)**操作实现进程控制。

**原语：**由<u>若干条指令</u>组成，完成特定的功能，是一种原子操作(Action Operation)

**原语的特点：**

- 原子操作，要么全做，要么全不做，执行过程不会被中断
- 在管态/系统态/内核态下执行，常驻内存
- 是内核三大支撑功能（中断处理/时钟管理/原语操作）之一

**几个常见的进程控制中的原语：**

> 两种状态：
>
> **活动阻塞**状态和**静止阻塞**状态都是指进程无法执行而等待某些事件发生的状态，活动阻塞状态下，进程仍然能够接收其他信号或者事件。**静止阻塞状态下，进程不能够接收其他信号或者事件。**
>
> **静止就绪**是指进程被调度出了主存，被放到了外存中，等待着系统资源的分配，此时进程不占用主存资源。需要重新调入主存中才能继续执行，因此它的启动时间较长，但也节省了主存的资源。
>
> **活动就绪**是指进程已经被调入主存中，并等待着CPU的分配，此时进程占用着主存资源。它能够立即被CPU分配到，启动时间较短，但也会占用主存的资源。

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230311092124147.png" alt="image-20230311092124147" style="zoom:50%;" />

1. **创建原语(Create)：**用于创建一个新进程，并为其分配必要的资源，如进程控制块（PCB）、程序计数器、内存空间等。Create原语通常包括以下步骤：
   - 分配PCB
   - 分配进程所需的系统资源
   - 初始化PCB信息，如进程ID、进程状态、程序计数器、内存地址等
   - 将新进程插入就绪队列，等待调度执行
2. **阻塞原语(Block)：**用于将一个进程从执行状态转变为阻塞状态，直到某个事件发生时才能被唤醒。Block原语通常包括以下步骤：
   - 修改进程状态为阻塞状态
   - 将进程从就绪队列中移除
   - 将进程插入到阻塞队列中
   - 调度其他进程执行
3. **唤醒原语(Wakeup)：**用于将一个被阻塞的进程从阻塞队列中移除，并将其插入到就绪队列中，使其可以继续执行。Wakeup原语通常包括以下步骤：
   - 从阻塞队列中选择一个被唤醒的进程
   - 修改进程状态为就绪状态
   - 将进程插入就绪队列中
   - 调度进程执行
4. **撤销原语(Destroy)**：用于撤销一个进程，并回收其所占用的所有资源，包括内存空间、打开的文件、进程控制块等。Destroy原语通常包括以下步骤：
   - 将进程从就绪队列或阻塞队列中移除
   - 释放进程占用的资源
   - 将进程控制块从系统中删除
   - 终止进程的执行
5. **挂起原语（suspend）：**当需要将一个正在执行的进程挂起时，需要使用挂起原语来实现。具体步骤如下：
   - 将进程的状态从活动状态（running）切换到挂起状态（suspended）。
   - 保存进程的上下文，包括程序计数器、寄存器等信息。
   -  将进程从调度队列中移除，不参与后续的调度。
   - 标记进程为挂起状态，并将其加入到挂起队列中，等待激活原语的调用。
6. **激活原语（active）：**当需要将一个挂起的进程重新激活时，需要使用激活原语来实现。具体步骤如下：
   - 将进程的状态从挂起状态（suspended）切换到就绪状态（ready）或者阻塞状态（blocked）。
   - 恢复进程的上下文，包括程序计数器、寄存器等信息。
   - 将进程加入到调度队列中，等待调度程序的调度。
   - 标记进程为活动状态（active）。

### 进程调度基础

**处理机调度：**根据一定的**算法和原则**将处理机资源进行**重新分配**的过程。

- **前提：**作业/进程数远远大于处理机数
- **目的：**提高资源利用率，减少处理机空闲时间，同时保证各个进程公平地获得CPU时间片，从而提高系统的吞吐量和响应性能。
- **调度程序（scheduler）：**是操作系统的一部分，负责管理系统中可运行进程（也称作任务）的调度。调度程序通过为进程分配CPU时间片，一方面要满足特定系统用户的需求（快速响应），另一方面要考虑系统整体效率（系统平均周转时间）和调度算法本身的开销。

#### 调度的层次

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230311095755479.png" alt="image-20230311095755479" style="zoom:40%;" />

**作业调度**（长期调度/高级调度），

- 从**外存**中挑选一个进程并将其**调入内存**中，即把后备作业调入内存，并为其分配必要的资源的过程，如为其创建进程控制块（PCB）。
- 只调入一次，调出一次
- 长期调度的开销较大，因此它的执行频率较低，通常是在几分钟或几个小时的时间尺度上进行一次。

**内存调度**（中期调度/中级调度/进程换入/换出调度）

- 在内存中的进程过多或内存不足时，将部分进程换出到外存，当条件合适在调入内存，保证在内存中维护足够的进程，避免内存饱和和死锁的发生。
- 在内、外存对换区进行进程对换
- 内存调度的执行频率比作业调度高，通常是在几秒钟的时间尺度上进行一次。

**进程调度**（短期调度/低级调度/CPU调度）

- 从就绪队列中选择一个进程，分配处理器并执行其代码的过程。使系统能够高效地使用CPU资源，提高系统的吞吐量和响应速度。
- 短期调度的执行频率最高，通常是在几毫秒的时间尺度上进行一次。

#### 调度方式

**剥夺式/抢占式调度**

抢占式调度是指进程可以被强制抢占CPU的调度算法，一般采用时间片轮转或优先级抢占等算法，可强制暂停正在执行的进程并分配CPU资源给更高优先级的进程。

- 立即暂停当前进程
- 分配改处理机给另一个进程
- 原则：优先权/短进程优先/时间片原侧

**非剥夺/非抢占式调度**

非抢占式调度不会主动强制暂停正在执行的进程，直到进程自己放弃CPU资源或者等待I/O等操作时才会进行调度。

- 若有进程请求执行，等待直到当前进程完成或阻塞
- 缺点：适用于批处理系统，不适用分时/实时系统

两者的区别在于抢占式调度可以**强制分配CPU资源给更高优先级的进程**，而非抢占式调度则需要**等待当前进程自己放弃CPU资源**。

#### 调度时机

- 进程运行完毕
- 进程时间片用完
- 进程要求I/O操作
- 执行某种原语操作
- 高优先级进程申请运行（剥夺式调度）

#### 调度过程

1. **保存镜像：**记录当前进程的状态，包括寄存器、程序计数器、进程状态等信息，以备将来恢复进程运行。
2. **调度算法：**根据调度算法的原则，决定哪个进程可以获得处理机，常见的调度算法有先来先服务、短作业优先、优先级调度、时间片轮转等。
3. **进程切换：**将处理机分配给下一个进程并切换到其运行。这个过程包括恢复下一个进程的现场和保存当前进程的现场。
4. **处理机回收：**当进程运行完毕或出现异常情况时，需要将处理机回收，同时将进程的状态置为完成或终止。

#### 调度算法指标

**进程调度算法有哪些评价指标？**

进程调度算法的评价指标主要包括CPU利用率、吞吐量、周转时间、等待时间、响应时间和公平性等。

- CPU利用率:arrow_up:：CPU的利用率 
  $$
  CPU利用率=\frac{忙碌时间}{总时间}
  $$

- 吞吐量:arrow_up:：单位时间内完成的进程数，

$$
吞吐量=\frac{完成作业数}{总时间}
$$

- 周转时间:arrow_down:：从进程进入系统到执行结束的时间，
  $$
  周转时间=作业完成时间-作业提交时间
  $$

  $$
  带权周转时间= \frac{周转时间}{实际运行时间}
  $$

​		实际运行中由于进程切换或者进程阻塞，作业实际运行时间远小于周转时间

- 等待时间:arrow_down:：作业等待处理机调度的时间，关注平均值
- 响应时间:arrow_down:：从发出请求到系统开始响应的时间
- 公平性：进程被分配到CPU的公平程度。

## 常见调度算法

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230311152505922.png" alt="image-20230311152505922" style="zoom:50%;" />

### 先来先服务(FCFS)

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230311151836933.png" alt="image-20230311151836933" style="zoom:33%;" />

**算法内容：**调度**作业/就绪**队列中最先入队者，等待操作完成或阻塞

**算法原：**按作业/进程到达顺序服务（执行）

**调度方式：**非抢占式调度

**适用场景：**适用于短作业占用资源少，进程到达时间分布均匀的场景。如作业/进程调度

**优缺点：**

- 有利于**CPU繁忙型**作业，充分利用CPU资源
- 不利于**I/O繁忙型**作业，操作耗时，其它饥饿

### 短作业优先(SJF)

**算法内容：**优先分配给需要执行时间最短的作业/进程。

**算法原则：**公平原则，优先分配CPU给执行时间短（最少的平均或带权周转时间）的进程。

**调度方式：**非抢占式调度

**使用场景：**适用于长作业和短作业混合的场景，需要保证快速响应的系统。

**优缺点：**

- 优点：平均等待/周转时间较短，长作业不会长时间占用处理机。
- 缺点：容易产生饥饿现象，对执行时间长的进程表现不佳。估计时间不准确，不能保证紧迫任务及时处理 

### 高响应比优先调度(HRRN)

**算法内容：**结合FCFS和SJF，综合考虑等待时间和服务时间计算响应比，响应高的进程优先执行。
$$
响应比=\frac{等待时间+服务时间}{服务时间},(\ge1)
$$

> 只有当前进程放弃执行权（完成/阻塞）时，重新计算所有进程响应比
>
> **长作业等待越久响应比越高，更容易获得处理机**

**算法原则：**公平原则，考虑了作业/进程的等待时间和执行时间。

**调度方式：**非抢占式。

**使用场景：**适用于对响应时间要求高的交互式系统。

**优缺点：**

- 优点：考虑了进程的等待时间和执行时间，能够减少饥饿现象。
- 缺点：需要对每个进程计算响应比，计算量较大。

### 优先级调度(PSA)

**算法内容：**按照优先级高低分配处理机，同一优先级按照FCFS原则分配。

优先级设置原则：

- 静态/动态优先级
- 系统 > 用户 ； 交互型 > 非交互型； I/O型 > 计算型 ；
- 低优先级进程可能会产生饥饿；

**算法原则：**公平原则，按照进程的优先级分配处理机。

**调度方式：**抢占/非抢占式。

**使用场景：**适用于不同进程有不同优先级的场景，如实时系统。

**优缺点：**

- 优点：考虑了进程的优先级，能够满足实时系统的需求。
- 缺点：可能会导致低优先级的

### 时间片轮转调度(RR)

**算法内容：**按进程到达就绪邹队列的顺序，轮流分配一个时间片去执行，时间用完则剥夺。

>  时间片决定因素：系统响应时间、就绪队列进程数量、系统处理能力

**算法原则：**公平、轮流为每个进程服务，进程在一定时间内都能得到响应

**调度方式：**抢占式调度，由**时钟中断**确定时间到。

**适用场景：**适用于对响应时间有较高要求的实时系统。如进程调度。

**优缺点：**

- 优点：公平，响应快，适用于分时系统

- 缺点：时间片大小的设置会影响响应时间和吞吐量。时间片太大，相当于FCFS；太小，处理机切换频繁，开销增大

### 多级反馈队列调度(MFQ)

**算法内容：**设置多个按优先级排序的就绪都队列。优先级从高到底，时间片从小到大。

新进程**采用队列降级法**进入第一级队列，按FCFS分时间片没有执行完，则进程进入下一级队列队尾。前面队列不为空，不执行后续队列进程，只有第 $k$ 级队列为空时，才会为 $k+1$ 级队头的进程分配时间片。

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230311151826380.png" alt="image-20230311151826380" style="zoom: 40%;" />

**算法原则：**集前几种算法优点，相当于PSA+RR

**调度方式：**抢占式

**适用场景：**进程调度

**优缺点**：

- **优点:**

各类型进程相对公平(**FCFS**的优点)；

每个新到达的进程都可以很快就得到响应(**RR**优点)；

短进程只用较少的时间就可完成(**SJF**优点)；

不必实现估计进程的运行时间；可灵活地调整对各类进程的偏好程度，比如**CPU**密集型进程、**I/O**密集型进程(拓展：可以将因**I/O**而阻塞的进程重新放回原队列，这样**I/O**型进程就可以保持较高优先)

- **缺点：**

实现起来比较复杂，需要考虑多个队列的管理和调度问题。

在高负载情况下，容易出现进程切换频繁的问题，影响系统的响应时间和性能。

对于长时间运行的进程，可能会出现饥饿的情况，影响系统的公平性。

## 进程之间的协作

### 进程通信

**进程通信：**进程通信即进程间的信息交换。

- **进程是资源分配的基本单位**，各进程内存空间**彼此独立**
- 一个进程不能随意直接访问其它进程的地址空间

**特点：**共享存储(Shared-Memory)、消息传递(Message-Passing)、管道通信(Pipe)

#### 共享存储(Shared-Memory)

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230312094402119.png" alt="image-20230312094402119" style="zoom:25%;" />

基于**共享数据结构**的通信方式：

- 多个进程共用**某个数据结构**（OS提供并控制），比如信号量、共享内存、消息队列等
- 由用户（程序员）负责同步处理
- 低级通信：可以传递少量数据，效率低

基于**共享存储区**的通信方式：

- 多个进程共用内存中的**一块存储区域**。常见的共享存储区包括共享内存和内存映射文件等
- 由进程控制数据的形式和方式。
- 需要进程间进行同步处理，避免出现数据冲突和竞争条件
- 高级通信：可以传递大量数据，效率高

共享存储区通信方式是通过多个进程共用内存中的一块存储区域进行通信的。因为数据存储在共享内存中，所以发送数据的进程并不知道接收数据的进程何时读取该数据，而接收数据的进程也不能确定发送数据的进程何时将该数据写入到共享内存中。这种不可见性会导致一些安全隐患，例如：

1. **内存读写冲突：**当两个进程同时对共享内存中的同一个位置进行读写操作时，就可能会导致数据出现冲突，进而产生数据错误的结果。
2. **数据泄漏：**如果进程A写入了一些敏感数据到共享内存中，但进程B并不应该访问这些数据，如果进程B错误地读取了这些数据，就会导致数据泄漏。
3. **竞态条件：**当多个进程同时访问共享内存中的数据时，就可能会出现竞态条件，导致数据不一致或出现错误。

#### 消息传递(Message-Passing)

**直接通信：点到点发送**

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230312102256294.png" alt="image-20230312102256294" style="zoom: 25%;" />

- 使用原语 `send` 和 `receive` 进行发送和接收，需要发送方和接收方之间建立连接，也就是需要知道对方的进程ID或进程名。
- 消息缓冲队列可以实现异步通信，发送方发送消息后不需要等待接收方接收消息，而是直接返回，并将消息存储在消息缓冲队列中，由接收方主动去队列中读取消息。

**间接通信：广播信箱**

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230312104355389.png" alt="image-20230312104355389" style="zoom:25%;" />

- 广播信箱通常由操作系统提供，作为中间实体，需要应用程序调用系统API来进行操作。每个进程可以选择向多个信箱发送消息，也可以从多个信箱接收消息。
- 广播信箱通常可以实现同步和异步通信，也就是发送方可以选择等待所有接收方都读取了消息之后才返回，或者不等待直接返回。

#### 管道通信(Pipe)

管道（Pipe）是一种半双工的通信方式，用于连接读进程和写进程的共享文件，即 pipe 文件。管道本质上是内存中固定大小的缓冲区，以先进先出（FIFO）方式组织数据传输，同一时段只能单向通信，双工通信需要两个管道。

<img src="/home/alivn/Documents/note/work/images/Blog/操作系统/image-20230312105925165.png" alt="image-20230312105925165" style="zoom:25%;" />

在 Linux 中，管道是由内核维护的，使用系统调用 `pipe()` 来创建。一个管道具有两个端点，分别称为读端和写端。管道数据读写是原子操作，使用系统调用 `read()`和 `write()`，保证了数据的可靠性。

管道一般是固定大小的，因此只有管道是空的时候才写，满的时候则不写；满的时候才读，空的时候不读；最后读后删除。

管道也存在一些缺点，比如只能传输顺序数据，不能实现随机访问，同时管道的容量也有限制，无法传输大量数据等。

### 进程同步

**进程同步：**协调并发执行的进程之间的相互制约关系，使它们按照预期的方式执行的过程。在并发执行的进程中，进程之间会相互竞争共享资源，而进程同步的主要目的是**确保对共享资源的访问是正确和一致的**，从而避免出现竞争条件和不确定性的结果。
前提：

- 进程是并发执行的，进程间存在着相互制约关系
- 并发的进程对系统共享资源进行竞争
- 进程通信，过程中相互发送的信号称为消息或事件

两种相互制约形式

- **间接相互制约关系（互斥）：**多个进程排他性地访问某个共享资源，以确保同一时间只有一个进程在使用该资源。实现互斥的方式包括使用锁、信号量等同步机制。
- **直接相互制约关系（同步）：**通过消息传递等方式进行协作，使它们按照某种特定的顺序执行。例如，在管道通信中，读进程必须等待写进程向管道中写入数据后才能读取数据，否则读进程会一直等待。

#### 互斥的访问临界资源

1. 进入区：尝试进入临界区，成功则加锁(`lock`)。
2. 临界区：访问共享资源。
3. 退出区：解锁(`unlock`)，唤醒其它阻塞进程。
4. 剩余区：其它代码。

其中，加锁(`lock`)和解锁( `unlock` )是两个关键的步骤，它们的目的是**保证在任何时候只有一个进程可以进入临界区**。具体来说，加锁( `lock` )会将一个标记置为被占用，而解锁( `unlock` )则会将这个标记清除，这样其它进程才有机会进入临界区。如果多个进程同时试图获取锁，其中只有一个进程能够成功获取锁，其它进程会被阻塞，直到锁被释放。

**访问原则：**

- **空闲让进：**临界区空闲，允许一个进程进入

- **忙则等待：**临界区已有进程，其它进程等待(阻塞状态)

- **有限等待：**处于等待状态的进程必须等待有限的时间。这个原则可以防止饥饿和死锁的发生，因为每个进程都有机会使用临界资源。

- **让权等待：**在等待时，进程应该让出CPU执行权，这样其他进程就有机会执行，防止“忙等待”。这个原则也有助于避免饥饿和死锁。

**软件实现方法：**

单标志法：违背"空闲让进

双标志法先检查

双标志法后检查

皮特森算法(Peterson's Algorithm)

## 死锁问题

### 死锁的概念



### 死锁的处理











## 进程

引入多道程序技术之后，为了方便操作系统管理，完成各程序并发执行，引入了进程、进程实体的概念。**PCB、程序段、数据段**三部分构成了进程实体（进程映像）；
一般情况下，我们把进程实体就简称为进程。例如，所谓创建进程，实质上是创建进程实体中的PCB，而撤销进程，实质上是撤销进程实体中的PCB。注意：**PCB是进程存在的唯一标志！**

从不同的角度，进程可以有不同的定义，比较传统典型的定义有：

- 进程是程序的**一次执行过程**。
- 进程是一个程序及其数据在处理机上顺序执行时所**发生的活动**。
- 进程是具有独立功能的程序在数据集合上**运行的过程**，它是系统进行资源分配和调度的一个独立单位

它们共同的特点就是强调进程是“动态性”的。

引入进程实体的概念后，可把进程定义为：

进程是进程实体的**运行过程**，是系统进行**资源分配和调度**的一个独立单位。

> 注：严格来说，进程实体和进程并不一样，**进程实体是静态的，进程则是动态的**。不过，除非题目专门
> 考察二者区别，否则可以认为进程实体就是进程。因此我们也可以说“进程由程序段、数据段、PCB三部
> 分组成”

### 进程的组成

进程（进程实体）由程序段、数据段、PCB三部分组成。

- PCB：**操作系统**通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需的各种信息。
- 程序段：**程序**代码即存放在此
- 数据段：**程序**运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量就存放在数据段内

<img src="/home/alivn/Documents/算法与面试/images/Blog/操作系统/image-20230302215603094.png" alt="image-20230302215603094" style="zoom:35%;" />

### 进程的组织

在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。

> 注：进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。

进程的组织方式：

- 链接方式：按照进程状态将PCB分为多个队列；操作系统持有指向各个队列的指针。

<img src="/home/alivn/Documents/算法与面试/images/Blog/操作系统/image-20230302220409285.png" alt="image-20230302220409285" style="zoom:53%;" />

- 索引方式：根据进程状态的不同，建立几张索引表；操作系统持有指向各个索引表的指针。

<img src="/home/alivn/Documents/算法与面试/images/Blog/操作系统/image-20230302220626427.png" alt="image-20230302220626427" style="zoom:50%;" />

### 进程的特征

- 动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的。动态性是进程最基本的特征。
- 并发性：内存中有多个进程实体，各进程可并发执行
- 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位。进程是资源分配、接受调度的基本单位。
- 异步性：各进程按各自独立的、不可预知的速度向前推进，异步性会导致并发程序执行结果的不确定性，操作系统要提供“进程同步机制”来解决异步问题。
- 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成

## 进程的状态与转换

进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。

进程的三种基本状态：

- **运行态(Running)：**占有CPU，并在CPU上运行。注意：单核处理机环境下，每一时刻最多只有一个进程处于运行态。（双核环境下可以同时有两个进程处于运行态)
- **就绪态(Ready)：**已经具备运行条件，但由于没有空闲CPU，而暂时不能运行。进程己经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。即：万事俱备，只欠CPU。
- **阻塞态(Waiting/Blocked，又称：等待态)：**因等待某一事件而暂时不能运行。如：等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务。

另外两种状态：

- **创建态(New,又称：新建态)：**进程正在被创建，操作系统为进程分配资源、初始化PCB
- **终止态(Terminated,又称：结束态)：**进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

进程的状态转换：

![image-20230303212938317](/home/alivn/Documents/算法与面试/images/Blog/操作系统/image-20230303212938317.png)

## 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销己有进程、实现
进程状态转换等功能。简化理解：**进程控制就是要实现进程状态转换**

![image-20230308202740239](/home/alivn/Documents/算法与面试/images/Blog/操作系统/image-20230308202740239.png)

 **如何实现进程控制？**
用**原语**实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。这种不可被中断的操作即原子操作。原语采用“关中断指令”和“开中断指令”实现。

**进程控制相关的原语**
学习技巧：进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：

1. 更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境

- 所有的进程控制原语一定都会修改进程状态标志
- 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
- 某进程开始运行前必然要恢复期运行环境

2. 将PCB插入合适的队列
3. 分配/回收资源

![image-20230308203354731](/home/alivn/Documents/算法与面试/images/Blog/操作系统/image-20230308203354731.png)

<img src="/home/alivn/Documents/算法与面试/images/Blog/操作系统/image-20230308203512144.png" alt="image-20230308203512144" style="zoom: 43%;" />

